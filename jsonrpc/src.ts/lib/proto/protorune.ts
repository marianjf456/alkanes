/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 6.30.2
 * source: protorune.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace protorune {
    export class RuneId extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            height?: number;
            txindex?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("height" in data && data.height != undefined) {
                    this.height = data.height;
                }
                if ("txindex" in data && data.txindex != undefined) {
                    this.txindex = data.txindex;
                }
            }
        }
        get height() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set height(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get txindex() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set txindex(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            height?: number;
            txindex?: number;
        }): RuneId {
            const message = new RuneId({});
            if (data.height != null) {
                message.height = data.height;
            }
            if (data.txindex != null) {
                message.txindex = data.txindex;
            }
            return message;
        }
        toObject() {
            const data: {
                height?: number;
                txindex?: number;
            } = {};
            if (this.height != null) {
                data.height = this.height;
            }
            if (this.txindex != null) {
                data.txindex = this.txindex;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.height != 0)
                writer.writeUint32(1, this.height);
            if (this.txindex != 0)
                writer.writeUint32(2, this.txindex);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RuneId {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RuneId();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.height = reader.readUint32();
                        break;
                    case 2:
                        message.txindex = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RuneId {
            return RuneId.deserialize(bytes);
        }
    }
    export class TransactionRecord extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            height?: number;
            transaction?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("height" in data && data.height != undefined) {
                    this.height = data.height;
                }
                if ("transaction" in data && data.transaction != undefined) {
                    this.transaction = data.transaction;
                }
            }
        }
        get height() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set height(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get transaction() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set transaction(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            height?: number;
            transaction?: Uint8Array;
        }): TransactionRecord {
            const message = new TransactionRecord({});
            if (data.height != null) {
                message.height = data.height;
            }
            if (data.transaction != null) {
                message.transaction = data.transaction;
            }
            return message;
        }
        toObject() {
            const data: {
                height?: number;
                transaction?: Uint8Array;
            } = {};
            if (this.height != null) {
                data.height = this.height;
            }
            if (this.transaction != null) {
                data.transaction = this.transaction;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.height != 0)
                writer.writeUint64(1, this.height);
            if (this.transaction.length)
                writer.writeBytes(2, this.transaction);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TransactionRecord {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TransactionRecord();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.height = reader.readUint64();
                        break;
                    case 2:
                        message.transaction = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TransactionRecord {
            return TransactionRecord.deserialize(bytes);
        }
    }
    export class ProtoruneRuneId extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            height?: uint128;
            txindex?: uint128;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("height" in data && data.height != undefined) {
                    this.height = data.height;
                }
                if ("txindex" in data && data.txindex != undefined) {
                    this.txindex = data.txindex;
                }
            }
        }
        get height() {
            return pb_1.Message.getWrapperField(this, uint128, 1) as uint128;
        }
        set height(value: uint128) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_height() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get txindex() {
            return pb_1.Message.getWrapperField(this, uint128, 2) as uint128;
        }
        set txindex(value: uint128) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_txindex() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            height?: ReturnType<typeof uint128.prototype.toObject>;
            txindex?: ReturnType<typeof uint128.prototype.toObject>;
        }): ProtoruneRuneId {
            const message = new ProtoruneRuneId({});
            if (data.height != null) {
                message.height = uint128.fromObject(data.height);
            }
            if (data.txindex != null) {
                message.txindex = uint128.fromObject(data.txindex);
            }
            return message;
        }
        toObject() {
            const data: {
                height?: ReturnType<typeof uint128.prototype.toObject>;
                txindex?: ReturnType<typeof uint128.prototype.toObject>;
            } = {};
            if (this.height != null) {
                data.height = this.height.toObject();
            }
            if (this.txindex != null) {
                data.txindex = this.txindex.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_height)
                writer.writeMessage(1, this.height, () => this.height.serialize(writer));
            if (this.has_txindex)
                writer.writeMessage(2, this.txindex, () => this.txindex.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ProtoruneRuneId {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ProtoruneRuneId();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.height, () => message.height = uint128.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.txindex, () => message.txindex = uint128.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ProtoruneRuneId {
            return ProtoruneRuneId.deserialize(bytes);
        }
    }
    export class Rune extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            runeId?: ProtoruneRuneId;
            name?: string;
            divisibility?: number;
            spacers?: number;
            symbol?: string;
            runes_symbol?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("runeId" in data && data.runeId != undefined) {
                    this.runeId = data.runeId;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("divisibility" in data && data.divisibility != undefined) {
                    this.divisibility = data.divisibility;
                }
                if ("spacers" in data && data.spacers != undefined) {
                    this.spacers = data.spacers;
                }
                if ("symbol" in data && data.symbol != undefined) {
                    this.symbol = data.symbol;
                }
                if ("runes_symbol" in data && data.runes_symbol != undefined) {
                    this.runes_symbol = data.runes_symbol;
                }
            }
        }
        get runeId() {
            return pb_1.Message.getWrapperField(this, ProtoruneRuneId, 1) as ProtoruneRuneId;
        }
        set runeId(value: ProtoruneRuneId) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_runeId() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get divisibility() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set divisibility(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get spacers() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set spacers(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get symbol() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set symbol(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get runes_symbol() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set runes_symbol(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            runeId?: ReturnType<typeof ProtoruneRuneId.prototype.toObject>;
            name?: string;
            divisibility?: number;
            spacers?: number;
            symbol?: string;
            runes_symbol?: number;
        }): Rune {
            const message = new Rune({});
            if (data.runeId != null) {
                message.runeId = ProtoruneRuneId.fromObject(data.runeId);
            }
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.divisibility != null) {
                message.divisibility = data.divisibility;
            }
            if (data.spacers != null) {
                message.spacers = data.spacers;
            }
            if (data.symbol != null) {
                message.symbol = data.symbol;
            }
            if (data.runes_symbol != null) {
                message.runes_symbol = data.runes_symbol;
            }
            return message;
        }
        toObject() {
            const data: {
                runeId?: ReturnType<typeof ProtoruneRuneId.prototype.toObject>;
                name?: string;
                divisibility?: number;
                spacers?: number;
                symbol?: string;
                runes_symbol?: number;
            } = {};
            if (this.runeId != null) {
                data.runeId = this.runeId.toObject();
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.divisibility != null) {
                data.divisibility = this.divisibility;
            }
            if (this.spacers != null) {
                data.spacers = this.spacers;
            }
            if (this.symbol != null) {
                data.symbol = this.symbol;
            }
            if (this.runes_symbol != null) {
                data.runes_symbol = this.runes_symbol;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_runeId)
                writer.writeMessage(1, this.runeId, () => this.runeId.serialize(writer));
            if (this.name.length)
                writer.writeString(2, this.name);
            if (this.divisibility != 0)
                writer.writeUint32(3, this.divisibility);
            if (this.spacers != 0)
                writer.writeUint32(4, this.spacers);
            if (this.symbol.length)
                writer.writeString(5, this.symbol);
            if (this.runes_symbol != 0)
                writer.writeUint32(6, this.runes_symbol);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Rune {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Rune();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.runeId, () => message.runeId = ProtoruneRuneId.deserialize(reader));
                        break;
                    case 2:
                        message.name = reader.readString();
                        break;
                    case 3:
                        message.divisibility = reader.readUint32();
                        break;
                    case 4:
                        message.spacers = reader.readUint32();
                        break;
                    case 5:
                        message.symbol = reader.readString();
                        break;
                    case 6:
                        message.runes_symbol = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Rune {
            return Rune.deserialize(bytes);
        }
    }
    export class BalanceSheetItem extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            rune?: Rune;
            balance?: uint128;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("rune" in data && data.rune != undefined) {
                    this.rune = data.rune;
                }
                if ("balance" in data && data.balance != undefined) {
                    this.balance = data.balance;
                }
            }
        }
        get rune() {
            return pb_1.Message.getWrapperField(this, Rune, 1) as Rune;
        }
        set rune(value: Rune) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_rune() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get balance() {
            return pb_1.Message.getWrapperField(this, uint128, 2) as uint128;
        }
        set balance(value: uint128) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_balance() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            rune?: ReturnType<typeof Rune.prototype.toObject>;
            balance?: ReturnType<typeof uint128.prototype.toObject>;
        }): BalanceSheetItem {
            const message = new BalanceSheetItem({});
            if (data.rune != null) {
                message.rune = Rune.fromObject(data.rune);
            }
            if (data.balance != null) {
                message.balance = uint128.fromObject(data.balance);
            }
            return message;
        }
        toObject() {
            const data: {
                rune?: ReturnType<typeof Rune.prototype.toObject>;
                balance?: ReturnType<typeof uint128.prototype.toObject>;
            } = {};
            if (this.rune != null) {
                data.rune = this.rune.toObject();
            }
            if (this.balance != null) {
                data.balance = this.balance.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_rune)
                writer.writeMessage(1, this.rune, () => this.rune.serialize(writer));
            if (this.has_balance)
                writer.writeMessage(2, this.balance, () => this.balance.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BalanceSheetItem {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BalanceSheetItem();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.rune, () => message.rune = Rune.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.balance, () => message.balance = uint128.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BalanceSheetItem {
            return BalanceSheetItem.deserialize(bytes);
        }
    }
    export class BalanceSheet extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            entries?: BalanceSheetItem[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("entries" in data && data.entries != undefined) {
                    this.entries = data.entries;
                }
            }
        }
        get entries() {
            return pb_1.Message.getRepeatedWrapperField(this, BalanceSheetItem, 1) as BalanceSheetItem[];
        }
        set entries(value: BalanceSheetItem[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            entries?: ReturnType<typeof BalanceSheetItem.prototype.toObject>[];
        }): BalanceSheet {
            const message = new BalanceSheet({});
            if (data.entries != null) {
                message.entries = data.entries.map(item => BalanceSheetItem.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                entries?: ReturnType<typeof BalanceSheetItem.prototype.toObject>[];
            } = {};
            if (this.entries != null) {
                data.entries = this.entries.map((item: BalanceSheetItem) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.entries.length)
                writer.writeRepeatedMessage(1, this.entries, (item: BalanceSheetItem) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BalanceSheet {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BalanceSheet();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.entries, () => pb_1.Message.addToRepeatedWrapperField(message, 1, BalanceSheetItem.deserialize(reader), BalanceSheetItem));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BalanceSheet {
            return BalanceSheet.deserialize(bytes);
        }
    }
    export class Outpoint extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            txid?: Uint8Array;
            vout?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("txid" in data && data.txid != undefined) {
                    this.txid = data.txid;
                }
                if ("vout" in data && data.vout != undefined) {
                    this.vout = data.vout;
                }
            }
        }
        get txid() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set txid(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get vout() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set vout(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            txid?: Uint8Array;
            vout?: number;
        }): Outpoint {
            const message = new Outpoint({});
            if (data.txid != null) {
                message.txid = data.txid;
            }
            if (data.vout != null) {
                message.vout = data.vout;
            }
            return message;
        }
        toObject() {
            const data: {
                txid?: Uint8Array;
                vout?: number;
            } = {};
            if (this.txid != null) {
                data.txid = this.txid;
            }
            if (this.vout != null) {
                data.vout = this.vout;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.txid.length)
                writer.writeBytes(1, this.txid);
            if (this.vout != 0)
                writer.writeUint32(2, this.vout);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Outpoint {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Outpoint();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.txid = reader.readBytes();
                        break;
                    case 2:
                        message.vout = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Outpoint {
            return Outpoint.deserialize(bytes);
        }
    }
    export class OutpointWithProtocol extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            txid?: Uint8Array;
            vout?: number;
            protocol?: uint128;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("txid" in data && data.txid != undefined) {
                    this.txid = data.txid;
                }
                if ("vout" in data && data.vout != undefined) {
                    this.vout = data.vout;
                }
                if ("protocol" in data && data.protocol != undefined) {
                    this.protocol = data.protocol;
                }
            }
        }
        get txid() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set txid(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get vout() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set vout(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get protocol() {
            return pb_1.Message.getWrapperField(this, uint128, 3) as uint128;
        }
        set protocol(value: uint128) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_protocol() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            txid?: Uint8Array;
            vout?: number;
            protocol?: ReturnType<typeof uint128.prototype.toObject>;
        }): OutpointWithProtocol {
            const message = new OutpointWithProtocol({});
            if (data.txid != null) {
                message.txid = data.txid;
            }
            if (data.vout != null) {
                message.vout = data.vout;
            }
            if (data.protocol != null) {
                message.protocol = uint128.fromObject(data.protocol);
            }
            return message;
        }
        toObject() {
            const data: {
                txid?: Uint8Array;
                vout?: number;
                protocol?: ReturnType<typeof uint128.prototype.toObject>;
            } = {};
            if (this.txid != null) {
                data.txid = this.txid;
            }
            if (this.vout != null) {
                data.vout = this.vout;
            }
            if (this.protocol != null) {
                data.protocol = this.protocol.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.txid.length)
                writer.writeBytes(1, this.txid);
            if (this.vout != 0)
                writer.writeUint32(2, this.vout);
            if (this.has_protocol)
                writer.writeMessage(3, this.protocol, () => this.protocol.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OutpointWithProtocol {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OutpointWithProtocol();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.txid = reader.readBytes();
                        break;
                    case 2:
                        message.vout = reader.readUint32();
                        break;
                    case 3:
                        reader.readMessage(message.protocol, () => message.protocol = uint128.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): OutpointWithProtocol {
            return OutpointWithProtocol.deserialize(bytes);
        }
    }
    export class Output extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            script?: Uint8Array;
            value?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("script" in data && data.script != undefined) {
                    this.script = data.script;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get script() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set script(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            script?: Uint8Array;
            value?: number;
        }): Output {
            const message = new Output({});
            if (data.script != null) {
                message.script = data.script;
            }
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                script?: Uint8Array;
                value?: number;
            } = {};
            if (this.script != null) {
                data.script = this.script;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.script.length)
                writer.writeBytes(1, this.script);
            if (this.value != 0)
                writer.writeUint64(2, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Output {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Output();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.script = reader.readBytes();
                        break;
                    case 2:
                        message.value = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Output {
            return Output.deserialize(bytes);
        }
    }
    export class OutpointResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            balances?: BalanceSheet;
            outpoint?: Outpoint;
            output?: Output;
            height?: number;
            txindex?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("balances" in data && data.balances != undefined) {
                    this.balances = data.balances;
                }
                if ("outpoint" in data && data.outpoint != undefined) {
                    this.outpoint = data.outpoint;
                }
                if ("output" in data && data.output != undefined) {
                    this.output = data.output;
                }
                if ("height" in data && data.height != undefined) {
                    this.height = data.height;
                }
                if ("txindex" in data && data.txindex != undefined) {
                    this.txindex = data.txindex;
                }
            }
        }
        get balances() {
            return pb_1.Message.getWrapperField(this, BalanceSheet, 1) as BalanceSheet;
        }
        set balances(value: BalanceSheet) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_balances() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get outpoint() {
            return pb_1.Message.getWrapperField(this, Outpoint, 2) as Outpoint;
        }
        set outpoint(value: Outpoint) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_outpoint() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get output() {
            return pb_1.Message.getWrapperField(this, Output, 3) as Output;
        }
        set output(value: Output) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_output() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get height() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set height(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get txindex() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set txindex(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            balances?: ReturnType<typeof BalanceSheet.prototype.toObject>;
            outpoint?: ReturnType<typeof Outpoint.prototype.toObject>;
            output?: ReturnType<typeof Output.prototype.toObject>;
            height?: number;
            txindex?: number;
        }): OutpointResponse {
            const message = new OutpointResponse({});
            if (data.balances != null) {
                message.balances = BalanceSheet.fromObject(data.balances);
            }
            if (data.outpoint != null) {
                message.outpoint = Outpoint.fromObject(data.outpoint);
            }
            if (data.output != null) {
                message.output = Output.fromObject(data.output);
            }
            if (data.height != null) {
                message.height = data.height;
            }
            if (data.txindex != null) {
                message.txindex = data.txindex;
            }
            return message;
        }
        toObject() {
            const data: {
                balances?: ReturnType<typeof BalanceSheet.prototype.toObject>;
                outpoint?: ReturnType<typeof Outpoint.prototype.toObject>;
                output?: ReturnType<typeof Output.prototype.toObject>;
                height?: number;
                txindex?: number;
            } = {};
            if (this.balances != null) {
                data.balances = this.balances.toObject();
            }
            if (this.outpoint != null) {
                data.outpoint = this.outpoint.toObject();
            }
            if (this.output != null) {
                data.output = this.output.toObject();
            }
            if (this.height != null) {
                data.height = this.height;
            }
            if (this.txindex != null) {
                data.txindex = this.txindex;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_balances)
                writer.writeMessage(1, this.balances, () => this.balances.serialize(writer));
            if (this.has_outpoint)
                writer.writeMessage(2, this.outpoint, () => this.outpoint.serialize(writer));
            if (this.has_output)
                writer.writeMessage(3, this.output, () => this.output.serialize(writer));
            if (this.height != 0)
                writer.writeUint32(4, this.height);
            if (this.txindex != 0)
                writer.writeUint32(5, this.txindex);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OutpointResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OutpointResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.balances, () => message.balances = BalanceSheet.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.outpoint, () => message.outpoint = Outpoint.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.output, () => message.output = Output.deserialize(reader));
                        break;
                    case 4:
                        message.height = reader.readUint32();
                        break;
                    case 5:
                        message.txindex = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): OutpointResponse {
            return OutpointResponse.deserialize(bytes);
        }
    }
    export class PaginationInput extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            start?: number;
            end?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("start" in data && data.start != undefined) {
                    this.start = data.start;
                }
                if ("end" in data && data.end != undefined) {
                    this.end = data.end;
                }
            }
        }
        get start() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set start(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get end() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set end(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            start?: number;
            end?: number;
        }): PaginationInput {
            const message = new PaginationInput({});
            if (data.start != null) {
                message.start = data.start;
            }
            if (data.end != null) {
                message.end = data.end;
            }
            return message;
        }
        toObject() {
            const data: {
                start?: number;
                end?: number;
            } = {};
            if (this.start != null) {
                data.start = this.start;
            }
            if (this.end != null) {
                data.end = this.end;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.start != 0)
                writer.writeUint32(1, this.start);
            if (this.end != 0)
                writer.writeUint32(2, this.end);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PaginationInput {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PaginationInput();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.start = reader.readUint32();
                        break;
                    case 2:
                        message.end = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PaginationInput {
            return PaginationInput.deserialize(bytes);
        }
    }
    export class WalletRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            wallet?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("wallet" in data && data.wallet != undefined) {
                    this.wallet = data.wallet;
                }
            }
        }
        get wallet() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set wallet(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            wallet?: Uint8Array;
        }): WalletRequest {
            const message = new WalletRequest({});
            if (data.wallet != null) {
                message.wallet = data.wallet;
            }
            return message;
        }
        toObject() {
            const data: {
                wallet?: Uint8Array;
            } = {};
            if (this.wallet != null) {
                data.wallet = this.wallet;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.wallet.length)
                writer.writeBytes(1, this.wallet);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WalletRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WalletRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.wallet = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): WalletRequest {
            return WalletRequest.deserialize(bytes);
        }
    }
    export class WalletResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            outpoints?: OutpointResponse[];
            balances?: BalanceSheet;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("outpoints" in data && data.outpoints != undefined) {
                    this.outpoints = data.outpoints;
                }
                if ("balances" in data && data.balances != undefined) {
                    this.balances = data.balances;
                }
            }
        }
        get outpoints() {
            return pb_1.Message.getRepeatedWrapperField(this, OutpointResponse, 1) as OutpointResponse[];
        }
        set outpoints(value: OutpointResponse[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get balances() {
            return pb_1.Message.getWrapperField(this, BalanceSheet, 2) as BalanceSheet;
        }
        set balances(value: BalanceSheet) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_balances() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            outpoints?: ReturnType<typeof OutpointResponse.prototype.toObject>[];
            balances?: ReturnType<typeof BalanceSheet.prototype.toObject>;
        }): WalletResponse {
            const message = new WalletResponse({});
            if (data.outpoints != null) {
                message.outpoints = data.outpoints.map(item => OutpointResponse.fromObject(item));
            }
            if (data.balances != null) {
                message.balances = BalanceSheet.fromObject(data.balances);
            }
            return message;
        }
        toObject() {
            const data: {
                outpoints?: ReturnType<typeof OutpointResponse.prototype.toObject>[];
                balances?: ReturnType<typeof BalanceSheet.prototype.toObject>;
            } = {};
            if (this.outpoints != null) {
                data.outpoints = this.outpoints.map((item: OutpointResponse) => item.toObject());
            }
            if (this.balances != null) {
                data.balances = this.balances.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.outpoints.length)
                writer.writeRepeatedMessage(1, this.outpoints, (item: OutpointResponse) => item.serialize(writer));
            if (this.has_balances)
                writer.writeMessage(2, this.balances, () => this.balances.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WalletResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WalletResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.outpoints, () => pb_1.Message.addToRepeatedWrapperField(message, 1, OutpointResponse.deserialize(reader), OutpointResponse));
                        break;
                    case 2:
                        reader.readMessage(message.balances, () => message.balances = BalanceSheet.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): WalletResponse {
            return WalletResponse.deserialize(bytes);
        }
    }
    export class ProtorunesWalletRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            wallet?: Uint8Array;
            protocol_tag?: uint128;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("wallet" in data && data.wallet != undefined) {
                    this.wallet = data.wallet;
                }
                if ("protocol_tag" in data && data.protocol_tag != undefined) {
                    this.protocol_tag = data.protocol_tag;
                }
            }
        }
        get wallet() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set wallet(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get protocol_tag() {
            return pb_1.Message.getWrapperField(this, uint128, 2) as uint128;
        }
        set protocol_tag(value: uint128) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_protocol_tag() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            wallet?: Uint8Array;
            protocol_tag?: ReturnType<typeof uint128.prototype.toObject>;
        }): ProtorunesWalletRequest {
            const message = new ProtorunesWalletRequest({});
            if (data.wallet != null) {
                message.wallet = data.wallet;
            }
            if (data.protocol_tag != null) {
                message.protocol_tag = uint128.fromObject(data.protocol_tag);
            }
            return message;
        }
        toObject() {
            const data: {
                wallet?: Uint8Array;
                protocol_tag?: ReturnType<typeof uint128.prototype.toObject>;
            } = {};
            if (this.wallet != null) {
                data.wallet = this.wallet;
            }
            if (this.protocol_tag != null) {
                data.protocol_tag = this.protocol_tag.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.wallet.length)
                writer.writeBytes(1, this.wallet);
            if (this.has_protocol_tag)
                writer.writeMessage(2, this.protocol_tag, () => this.protocol_tag.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ProtorunesWalletRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ProtorunesWalletRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.wallet = reader.readBytes();
                        break;
                    case 2:
                        reader.readMessage(message.protocol_tag, () => message.protocol_tag = uint128.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ProtorunesWalletRequest {
            return ProtorunesWalletRequest.deserialize(bytes);
        }
    }
    export class RunesByHeightRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            height?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("height" in data && data.height != undefined) {
                    this.height = data.height;
                }
            }
        }
        get height() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set height(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            height?: number;
        }): RunesByHeightRequest {
            const message = new RunesByHeightRequest({});
            if (data.height != null) {
                message.height = data.height;
            }
            return message;
        }
        toObject() {
            const data: {
                height?: number;
            } = {};
            if (this.height != null) {
                data.height = this.height;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.height != 0)
                writer.writeUint64(1, this.height);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RunesByHeightRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RunesByHeightRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.height = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RunesByHeightRequest {
            return RunesByHeightRequest.deserialize(bytes);
        }
    }
    export class RunesResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            runes?: Rune[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("runes" in data && data.runes != undefined) {
                    this.runes = data.runes;
                }
            }
        }
        get runes() {
            return pb_1.Message.getRepeatedWrapperField(this, Rune, 1) as Rune[];
        }
        set runes(value: Rune[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            runes?: ReturnType<typeof Rune.prototype.toObject>[];
        }): RunesResponse {
            const message = new RunesResponse({});
            if (data.runes != null) {
                message.runes = data.runes.map(item => Rune.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                runes?: ReturnType<typeof Rune.prototype.toObject>[];
            } = {};
            if (this.runes != null) {
                data.runes = this.runes.map((item: Rune) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.runes.length)
                writer.writeRepeatedMessage(1, this.runes, (item: Rune) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RunesResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RunesResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.runes, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Rune.deserialize(reader), Rune));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RunesResponse {
            return RunesResponse.deserialize(bytes);
        }
    }
    export class ProtoBurn extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            protocol_tag?: uint128;
            pointer?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("protocol_tag" in data && data.protocol_tag != undefined) {
                    this.protocol_tag = data.protocol_tag;
                }
                if ("pointer" in data && data.pointer != undefined) {
                    this.pointer = data.pointer;
                }
            }
        }
        get protocol_tag() {
            return pb_1.Message.getWrapperField(this, uint128, 1) as uint128;
        }
        set protocol_tag(value: uint128) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_protocol_tag() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get pointer() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set pointer(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            protocol_tag?: ReturnType<typeof uint128.prototype.toObject>;
            pointer?: number;
        }): ProtoBurn {
            const message = new ProtoBurn({});
            if (data.protocol_tag != null) {
                message.protocol_tag = uint128.fromObject(data.protocol_tag);
            }
            if (data.pointer != null) {
                message.pointer = data.pointer;
            }
            return message;
        }
        toObject() {
            const data: {
                protocol_tag?: ReturnType<typeof uint128.prototype.toObject>;
                pointer?: number;
            } = {};
            if (this.protocol_tag != null) {
                data.protocol_tag = this.protocol_tag.toObject();
            }
            if (this.pointer != null) {
                data.pointer = this.pointer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_protocol_tag)
                writer.writeMessage(1, this.protocol_tag, () => this.protocol_tag.serialize(writer));
            if (this.pointer != 0)
                writer.writeUint32(2, this.pointer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ProtoBurn {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ProtoBurn();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.protocol_tag, () => message.protocol_tag = uint128.deserialize(reader));
                        break;
                    case 2:
                        message.pointer = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ProtoBurn {
            return ProtoBurn.deserialize(bytes);
        }
    }
    export class uint128 extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            lo?: string;
            hi?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("lo" in data && data.lo != undefined) {
                    this.lo = data.lo;
                }
                if ("hi" in data && data.hi != undefined) {
                    this.hi = data.hi;
                }
            }
        }
        get lo() {
            return pb_1.Message.getFieldWithDefault(this, 1, "0") as string;
        }
        set lo(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get hi() {
            return pb_1.Message.getFieldWithDefault(this, 2, "0") as string;
        }
        set hi(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            lo?: string;
            hi?: string;
        }): uint128 {
            const message = new uint128({});
            if (data.lo != null) {
                message.lo = data.lo;
            }
            if (data.hi != null) {
                message.hi = data.hi;
            }
            return message;
        }
        toObject() {
            const data: {
                lo?: string;
                hi?: string;
            } = {};
            if (this.lo != null) {
                data.lo = this.lo;
            }
            if (this.hi != null) {
                data.hi = this.hi;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.lo != "0")
                writer.writeUint64String(1, this.lo);
            if (this.hi != "0")
                writer.writeUint64String(2, this.hi);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): uint128 {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new uint128();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.lo = reader.readUint64String();
                        break;
                    case 2:
                        message.hi = reader.readUint64String();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): uint128 {
            return uint128.deserialize(bytes);
        }
    }
    export class Clause extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            rune?: ProtoruneRuneId;
            amount?: uint128;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("rune" in data && data.rune != undefined) {
                    this.rune = data.rune;
                }
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
            }
        }
        get rune() {
            return pb_1.Message.getWrapperField(this, ProtoruneRuneId, 1) as ProtoruneRuneId;
        }
        set rune(value: ProtoruneRuneId) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_rune() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get amount() {
            return pb_1.Message.getWrapperField(this, uint128, 2) as uint128;
        }
        set amount(value: uint128) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_amount() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            rune?: ReturnType<typeof ProtoruneRuneId.prototype.toObject>;
            amount?: ReturnType<typeof uint128.prototype.toObject>;
        }): Clause {
            const message = new Clause({});
            if (data.rune != null) {
                message.rune = ProtoruneRuneId.fromObject(data.rune);
            }
            if (data.amount != null) {
                message.amount = uint128.fromObject(data.amount);
            }
            return message;
        }
        toObject() {
            const data: {
                rune?: ReturnType<typeof ProtoruneRuneId.prototype.toObject>;
                amount?: ReturnType<typeof uint128.prototype.toObject>;
            } = {};
            if (this.rune != null) {
                data.rune = this.rune.toObject();
            }
            if (this.amount != null) {
                data.amount = this.amount.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_rune)
                writer.writeMessage(1, this.rune, () => this.rune.serialize(writer));
            if (this.has_amount)
                writer.writeMessage(2, this.amount, () => this.amount.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Clause {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Clause();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.rune, () => message.rune = ProtoruneRuneId.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.amount, () => message.amount = uint128.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Clause {
            return Clause.deserialize(bytes);
        }
    }
    export class Predicate extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            clauses?: Clause[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("clauses" in data && data.clauses != undefined) {
                    this.clauses = data.clauses;
                }
            }
        }
        get clauses() {
            return pb_1.Message.getRepeatedWrapperField(this, Clause, 1) as Clause[];
        }
        set clauses(value: Clause[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            clauses?: ReturnType<typeof Clause.prototype.toObject>[];
        }): Predicate {
            const message = new Predicate({});
            if (data.clauses != null) {
                message.clauses = data.clauses.map(item => Clause.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                clauses?: ReturnType<typeof Clause.prototype.toObject>[];
            } = {};
            if (this.clauses != null) {
                data.clauses = this.clauses.map((item: Clause) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.clauses.length)
                writer.writeRepeatedMessage(1, this.clauses, (item: Clause) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Predicate {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Predicate();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.clauses, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Clause.deserialize(reader), Clause));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Predicate {
            return Predicate.deserialize(bytes);
        }
    }
    export class ProtoMessage extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            calldata?: Uint8Array;
            predicate?: Predicate;
            pointer?: number;
            refund_pointer?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("calldata" in data && data.calldata != undefined) {
                    this.calldata = data.calldata;
                }
                if ("predicate" in data && data.predicate != undefined) {
                    this.predicate = data.predicate;
                }
                if ("pointer" in data && data.pointer != undefined) {
                    this.pointer = data.pointer;
                }
                if ("refund_pointer" in data && data.refund_pointer != undefined) {
                    this.refund_pointer = data.refund_pointer;
                }
            }
        }
        get calldata() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set calldata(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get predicate() {
            return pb_1.Message.getWrapperField(this, Predicate, 2) as Predicate;
        }
        set predicate(value: Predicate) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_predicate() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get pointer() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set pointer(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get refund_pointer() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set refund_pointer(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            calldata?: Uint8Array;
            predicate?: ReturnType<typeof Predicate.prototype.toObject>;
            pointer?: number;
            refund_pointer?: number;
        }): ProtoMessage {
            const message = new ProtoMessage({});
            if (data.calldata != null) {
                message.calldata = data.calldata;
            }
            if (data.predicate != null) {
                message.predicate = Predicate.fromObject(data.predicate);
            }
            if (data.pointer != null) {
                message.pointer = data.pointer;
            }
            if (data.refund_pointer != null) {
                message.refund_pointer = data.refund_pointer;
            }
            return message;
        }
        toObject() {
            const data: {
                calldata?: Uint8Array;
                predicate?: ReturnType<typeof Predicate.prototype.toObject>;
                pointer?: number;
                refund_pointer?: number;
            } = {};
            if (this.calldata != null) {
                data.calldata = this.calldata;
            }
            if (this.predicate != null) {
                data.predicate = this.predicate.toObject();
            }
            if (this.pointer != null) {
                data.pointer = this.pointer;
            }
            if (this.refund_pointer != null) {
                data.refund_pointer = this.refund_pointer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.calldata.length)
                writer.writeBytes(1, this.calldata);
            if (this.has_predicate)
                writer.writeMessage(2, this.predicate, () => this.predicate.serialize(writer));
            if (this.pointer != 0)
                writer.writeUint32(3, this.pointer);
            if (this.refund_pointer != 0)
                writer.writeUint32(4, this.refund_pointer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ProtoMessage {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ProtoMessage();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.calldata = reader.readBytes();
                        break;
                    case 2:
                        reader.readMessage(message.predicate, () => message.predicate = Predicate.deserialize(reader));
                        break;
                    case 3:
                        message.pointer = reader.readUint32();
                        break;
                    case 4:
                        message.refund_pointer = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ProtoMessage {
            return ProtoMessage.deserialize(bytes);
        }
    }
    export class RuntimeInput extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            protocol_tag?: uint128;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("protocol_tag" in data && data.protocol_tag != undefined) {
                    this.protocol_tag = data.protocol_tag;
                }
            }
        }
        get protocol_tag() {
            return pb_1.Message.getWrapperField(this, uint128, 1) as uint128;
        }
        set protocol_tag(value: uint128) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_protocol_tag() {
            return pb_1.Message.getField(this, 1) != null;
        }
        static fromObject(data: {
            protocol_tag?: ReturnType<typeof uint128.prototype.toObject>;
        }): RuntimeInput {
            const message = new RuntimeInput({});
            if (data.protocol_tag != null) {
                message.protocol_tag = uint128.fromObject(data.protocol_tag);
            }
            return message;
        }
        toObject() {
            const data: {
                protocol_tag?: ReturnType<typeof uint128.prototype.toObject>;
            } = {};
            if (this.protocol_tag != null) {
                data.protocol_tag = this.protocol_tag.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_protocol_tag)
                writer.writeMessage(1, this.protocol_tag, () => this.protocol_tag.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RuntimeInput {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RuntimeInput();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.protocol_tag, () => message.protocol_tag = uint128.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RuntimeInput {
            return RuntimeInput.deserialize(bytes);
        }
    }
    export class Runtime extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            balances?: BalanceSheet;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("balances" in data && data.balances != undefined) {
                    this.balances = data.balances;
                }
            }
        }
        get balances() {
            return pb_1.Message.getWrapperField(this, BalanceSheet, 1) as BalanceSheet;
        }
        set balances(value: BalanceSheet) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_balances() {
            return pb_1.Message.getField(this, 1) != null;
        }
        static fromObject(data: {
            balances?: ReturnType<typeof BalanceSheet.prototype.toObject>;
        }): Runtime {
            const message = new Runtime({});
            if (data.balances != null) {
                message.balances = BalanceSheet.fromObject(data.balances);
            }
            return message;
        }
        toObject() {
            const data: {
                balances?: ReturnType<typeof BalanceSheet.prototype.toObject>;
            } = {};
            if (this.balances != null) {
                data.balances = this.balances.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_balances)
                writer.writeMessage(1, this.balances, () => this.balances.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Runtime {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Runtime();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.balances, () => message.balances = BalanceSheet.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Runtime {
            return Runtime.deserialize(bytes);
        }
    }
    export class ProtorunesByHeightRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            height?: number;
            protocol_tag?: uint128;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("height" in data && data.height != undefined) {
                    this.height = data.height;
                }
                if ("protocol_tag" in data && data.protocol_tag != undefined) {
                    this.protocol_tag = data.protocol_tag;
                }
            }
        }
        get height() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set height(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get protocol_tag() {
            return pb_1.Message.getWrapperField(this, uint128, 2) as uint128;
        }
        set protocol_tag(value: uint128) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_protocol_tag() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            height?: number;
            protocol_tag?: ReturnType<typeof uint128.prototype.toObject>;
        }): ProtorunesByHeightRequest {
            const message = new ProtorunesByHeightRequest({});
            if (data.height != null) {
                message.height = data.height;
            }
            if (data.protocol_tag != null) {
                message.protocol_tag = uint128.fromObject(data.protocol_tag);
            }
            return message;
        }
        toObject() {
            const data: {
                height?: number;
                protocol_tag?: ReturnType<typeof uint128.prototype.toObject>;
            } = {};
            if (this.height != null) {
                data.height = this.height;
            }
            if (this.protocol_tag != null) {
                data.protocol_tag = this.protocol_tag.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.height != 0)
                writer.writeUint64(1, this.height);
            if (this.has_protocol_tag)
                writer.writeMessage(2, this.protocol_tag, () => this.protocol_tag.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ProtorunesByHeightRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ProtorunesByHeightRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.height = reader.readUint64();
                        break;
                    case 2:
                        reader.readMessage(message.protocol_tag, () => message.protocol_tag = uint128.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ProtorunesByHeightRequest {
            return ProtorunesByHeightRequest.deserialize(bytes);
        }
    }
}
